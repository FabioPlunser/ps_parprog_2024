from matplotlib import pyplot as plt
from os import PathLike
from functools import reduce
from typing import Dict, List, Tuple


def to_markdown(result: Dict[str, List[Tuple[int, float]]]) -> str:
    """Converts the result of a benchmark generated by `join_benchmark_results()` to a markdown table."""

    # generate markdown table header and separator
    header = "| num_threads | " + " | ".join(result.keys()) + " |"
    separator = "|" + "|".join(["---"] * (len(result) + 1)) + "|"

    # generate data region of markdown table
    # find unique number of threads
    unique_num_threads = set(
        reduce(
            lambda x, y: x + y,
            [[num_threads for num_threads, _ in program_results] for program_results in result.values()],
            [],
        )
    )

    # generate data rows for each number of threads
    data = []
    for num_threads in unique_num_threads:
        data_row = []
        for program in result:
            for measurement in result[program]:
                if measurement[0] == num_threads:
                    data_row.append(f"{measurement[1]:.3f}s")
                    break
            else:
                data_row.append("-")
        data.append(f"| {num_threads} | {' | '.join(data_row)} |")

    return "\n".join([header, separator] + data)


def plot_benchmark(
    title: str, result: Dict[str, List[Tuple[int, float]]], output_file: PathLike, width: int = 1000, height: int = 600
):
    """Creates a plot of the benchmark result and exports it as a file to the specified path."""
    plt.figure(figsize=(width / 100, height / 100))

    # plot result of individual programs as lines
    line_handles = []
    for program in result:
        num_threads, runtime = zip(*result[program])
        line_handles.append(plt.plot(num_threads, runtime, label=program, marker="x")[0])

    # plot legend
    plt.legend(handles=line_handles)

    # plot axis labels, title, etc.
    plt.xlabel("Number of threads")
    plt.ylabel("Runtime [s]")
    plt.title(title, fontdict={"fontsize": 20})
    plt.grid()
    plt.xlim(0.5, int(plt.gca().get_xlim()[1]) + 0.5)
    plt.ylim(0)

    plt.xticks([i for i in range(1, int(plt.gca().get_xlim()[1]) + 1)])

    plt.savefig(output_file)
